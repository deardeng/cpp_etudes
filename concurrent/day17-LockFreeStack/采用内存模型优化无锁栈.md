
## 简介
前文我们通过引用计数实现了无锁并发的栈结构，但是对于原子变量的读，写以及读改写操作默认采用的是`memory_order_seq_cst`,`memory_order_seq_cst`为全局顺序模型，也就是所有线程看到的执行顺序一致，但是这种模型对性能消耗较大，本文在之前实现的无锁栈的基础上介绍如何通过更为宽松的模型提升性能。

## release-acquire

我们在之前的文章介绍了6中内存顺序，其中我们可以通过`release`和`acquire`的方式实现同步的效果，现在带着大家复习一下：

线程A执行store操作，采用`memory_order_release`顺序模型。线程B执行load操作采用`memory_order_acquire`顺序模型。如果线程B的load操作读取到A操作的store操作的数值，我们称A线程store操作先行于B线程的load操作，进而得出store操作的结果同步给load操作, A线程和B线程构成了release-sequence(C++并发编程一书中将其称为释放序列)。所以我们得出如下结论

采用release-acquire内存顺序，线程A的load操作加载了线程B store操作的结果，则称B synchronizes with A。

写个代码复习一下
``` cpp
void TestReleaseSeq() {
	int data = 0;
	std::atomic<int> flag = 0;
	std::thread t1([&]() {
		data = 42;  //1
		flag.store(1, std::memory_order_release); //2
		});

	std::thread  t2([&]() {
		//3
		while (!flag.load(std::memory_order_acquire));
		//4 
		assert(data == 42);
	});

	t1.join();
	t2.join();
}
```
上面的代码2处的结果会同步给3处，形成release-sequence, 我们称2 synchronizes with 3。进而得出2 happens-before 3.

前文我们介绍了happens-before 关系可以扩展, 因为1 happens before 2, 而3 happens before 4， 那么2 happens before 4。 所以4处代码断言为真不会崩溃。

## 释放序列的扩展

这段文字摘录于C++并发编程一书

> 如果存储操作的标记是memory_order_release、memory_order_acq_rel或memory_order_seq_cst，而载入操作则以memory_order_consume、memory_order_acquire或memory_order_seq_cst标记，这些操作前后相扣成链，每次载入的值都源自前面的存储操作，那么该操作链由一个释放序列组成。若最后的载入操作服从内存次序memory_order_acquire或memory_order_seq_cst，则最初的存储操作与它构成同步关系。但如果该载入操作服从的内存次序是memory_order_consume，那么两者构成前序依赖关系。操作链中，每个“读-改-写”操作都可选用任意内存次序，甚至也能选用memory_order_relaxed次序。

我们对上述阐述总结为下面的理解

release-sequnece的概念如下：

针对一个原子变量 M 的 release 操作 A 完成后, 接下来 M 上可能还会有一连串的其他操作. 如果这一连串操作是由

1  同一线程上的写操作

2  或者任意线程上的 read-modify-write 操作

这两种构成的, 则称这一连串的操作为以 release 操作 A 为首的 release sequence. 这里的写操作和 read-modify-write 操作可以使用任意内存顺序.

而同步的概念是：

一个 acquire 操作在同一个原子变量上读到了一个 release 操作写入的值, 或者读到了以这个 release 操作为首的 release sequence 写入的值, 那么这个 release 操作 “synchronizes-with” 这个 acquire 操作

所以release-sequence不一定构成同步，只有acquire到release的值才算作同步。

我们看下面的例子,该例子选取自C++ 并发编程中，我对其稍作修改以保证可以正常运行。

我们先定义了三个全局变量，分别是queue_data表示入队的数据，count表示入队的数量。store_finish表示存储完成。
``` cpp
std::vector<int> queue_data;
std::atomic<int> count;
std::atomic<bool> store_finish = false;
```
我们实现入队逻辑，这个逻辑以后会有一个线程独立执行
``` cpp
void populate_queue()
{
	unsigned const number_of_items = 20;
	queue_data.clear();
	for (unsigned i = 0; i < number_of_items; ++i)
	{
		queue_data.push_back(i);
	}
	// 1 最初的存储操作
	count.store(number_of_items, std::memory_order_release);   
	store_finish.store(true, std::memory_order_relaxed);
}
```
上述函数将20个元素从0到19依次入队，然后修改count值为20，使用release内存顺序，并且将完成标记设置为true.

然后我们实现消费函数
``` cpp
void consume_queue_items()
{
	while (true)
	{
		//2等待存储完成
		while (!store_finish.load(std::memory_order_relaxed));

		int item_index;
		//3 读—改—写”操作
		if ((item_index = count.fetch_sub(1, std::memory_order_acquire)) <= 0)   
		{
			return;
		}
		//4 从内部容器queue_data 读取数据项是安全行为
		std::cout << "queue_data is  " << queue_data[item_index-1] << std::endl;
	}
}
```
上述函数，我们在2处等待存储完成，在3处读改写修改count的值，采用的是acquire内存顺序，然后我们从队列中根据item_index读取数据。

假设一个线程t1用来执行populate_queue，一个线程t2用来执行consume_queue_items。

那么因为release-acquire的关系，我们可以推断出 t1 synchronizes-with t2.

那我们用三个线程并行操作会怎样呢？
``` cpp
void TestReleaseSeq2() {
	std::thread a(populate_queue);
	std::thread b(consume_queue_items);
	std::thread c(consume_queue_items);
	a.join();
	b.join();
	c.join();
}
```
可以看到输出如下

![https://cdn.llfc.club/1703586901585.jpg](https://cdn.llfc.club/1703586901585.jpg)

虽然控制台打印混乱，但是我们可以看到消费者线程t2和t3并没有打印重复的数据，说明他们互斥