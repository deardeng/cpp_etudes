## 简介
到目前为止，前面一系列的文章已经将多线程编程技术介绍完了，很多人问我如何排查多线程程序的问题，本节是最后一节，给大家提供一些在多线程编程过程中排查问题的思路。因为本节代码演示和实际操作内容较多，该文档仅做基本的说明，详细操作可看视频， 视频链接：

[https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290](https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290)

## 常见问题
在介绍如何排查前我们先将问题做几个归类：
1. 内存问题，包括内存泄露(未回收内存)，空指针，悬垂指针(野指针)，double free问题等。
2. 资源竞争，多个线程竞争同一块临界区的资源，未保证互斥
3. 死锁(互相引用阻塞卡死)和活锁(乐观锁尝试)
4. 引用已释放的变量，生命周期管理失效导致
5. 线程管控失败，修改或者回收一个已经绑定正在运行线程的变量，或者线程本该回收却被卡死，皆因线程管控失败导致
6. 智能指针和裸指针混用导致二次析构，也属于double free。

接下来根据上面列出的问题，我们根据实际案例排查出现问题的原因以及规避的方法。

接下来的案例均取自我的源码，源码链接如下：

[https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot](https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot)


## 空指针
空指针的问题比较好排查，我们在封装无锁队列的时候照抄《C++并发编程实战》一书引发了崩溃，详见源码链接中crushque.h以及lockfreequetest.cpp。

测试用例如下：
``` cpp
void TestCrushQue() {
	crush_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT * 10000; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
		});

	std::thread t2([&]() {
		for (int i = 0; i < TESTCOUNT * 10000;) {
			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			i++;
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();
	t2.join();

}
```

最后显示的崩溃点在

![https://cdn.llfc.club/1708328384150.jpg](https://cdn.llfc.club/1708328384150.jpg)

很明显这是引发崩溃的底层代码，并不是上层代码，通过调用堆栈找到和崩溃最相近的逻辑

![https://cdn.llfc.club/1708328755799.jpg](https://cdn.llfc.club/1708328755799.jpg)

我们点击第二行的栈调用跳转到队列的push操作。

![https://cdn.llfc.club/1708328906480.jpg](https://cdn.llfc.club/1708328906480.jpg)

在代码166行处是崩溃的上层调用，我们通过分析old_tail.ptr此时为空指针，该问题的根因在于构造无锁队列时未进行头节点和尾部节点的初始化所致。

无论linux还是windows，排查崩溃问题最首要的解决方式为观察栈调用，gdb或者windows的栈信息直观的反应了崩溃的触发顺序。

## 内存泄漏

一般来说内存泄漏检测有专门的工具库，linux环境下可使用valgrind，windows的visual studio环境下Visual Leak Detector， 这些工具只能被动的检测内存泄漏，很多情况我们需要针对已经开发的类或者逻辑编写测试用例，检测内存泄漏。

比如我们对于无锁队列中提供了一个内存泄漏的版本，详见memoryleakque.h以及测试用例lockfreequetest.cpp，以下为测试代码
``` cpp
void TestLeakQue() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
		});

	std::thread t2([&]() {
		for (int i = 0; i < TESTCOUNT;) {
			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			i++;
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();
	t2.join();

	assert(que.destruct_count == TESTCOUNT);

}
```

针对这个队列, 我们统计释放节点的个数和开辟节点的个数是否相等，通过`assert(que.destruct_count == TESTCOUNT);`断言检测，实际测试过程中发现存在内存泄漏。

![https://cdn.llfc.club/1708330464493.jpg](https://cdn.llfc.club/1708330464493.jpg)

针对无锁队列的内存泄漏无外乎就是push和pop操作造成的，我们把测试用例改为单线程，先将多线程这个可变因素去掉
``` cpp
void TestLeakQueSingleThread() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));

			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();

	assert(que.destruct_count == TESTCOUNT);
}
```
上面的代码测试未发现内存泄漏，但这还不能将问题归因于多线程，我们构造一种情况触发空队列的pop
``` cpp
void TestLeakQueMultiPop() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));

			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p << std::endl;

			auto p2 = que.pop();
			if (p2 == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p2 << std::endl;
		}
		});

	t1.join();

	assert(que.destruct_count == TESTCOUNT);
}
```
上面的代码再一次触发断言，说明存在内存泄漏，那我们可以将问题归因于pop操作，而且是队列为空的pop操作。

接下来配合断点调试，windows断点调试较为方便，或者linux环境gdb调试麻烦，可以在关键点打印信息排查问题。

我们使用visual studio断点排查这个问题，先让队列push一个数据，再pop两次，第二次pop肯定无效因为是空队列，但也是引发泄漏的关键原因。

接下来再push一个数据，再pop节点，我们需观察这次pop是否会触发节点回收的逻辑。

回收节点的逻辑只有两处，在release_ref和free_external_counter内部判断internal_count和external_counters为0时才会调用delete回收内存，所以我们只需要在release_ref和free_external_counter中打断点，观察这两个引用计数是否为0，如果不为0说明引用计数的计算出了问题。

![https://cdn.llfc.club/1708334690329.jpg](https://cdn.llfc.club/1708334690329.jpg)

为了便于观察数据，我们采取单步调试的方式，经过断点调试，发现第二次循环pop时，`free_external_count`内部`old_node_ptr.external_count`为3，而第一次循环pop时`old_node_ptr.external_count`为2. 那么第二次计算`internal_count`就不会为0，导致节点不会回收。

问题的根因也找到了在pop判断队列为空的时候直接返回了，之前进行了`increase_external_count`将外部引用计数增加了，在判断队列为空未进行修改就返回了，我们知道外部引用计数只是一个副本，可能同时有多个线程修改外部引用计数，所以只需要让内部引用计数释放一次即可
``` cpp
if (ptr == tail.load().ptr)
{
    ptr->release_ref();
    return std::unique_ptr<T>();
}
```
再次测试未发现内存泄漏。

自己设计测试用例时要注意覆盖多种情况，比如无锁队列，我后来又测试了单线程，多线程一进一出，多线程一进多出，多线程一出多进，多线程多出多进等，以及加大线程数测试。详细案例可以看看源码， lockfreequetest.cpp。

## double free
对于悬垂指针也叫做野指针，指的是释放内存后，再次使用这个指针访问数据造成崩溃。double free也属于指针管理失效导致，我们看看网络编程中对官方案例存在隐患的剖析。案例在网络编程network文件夹，day05-AsyncServer中，我们实现了一个异步的echo应答server。
正常情况下应答server没有任何问题，但是对于全双工情况(实际情况都是收发解耦合)，比如我们在收到消息后监听读事件，并发送，而不是在发送消息后监听读事件。我们将handle_read处理改为如下
``` cpp
void Session::handle_read(const boost::system::error_code& error, size_t bytes_transfered) {

	if (!error) {
		cout << "server receive data is " << _data << endl;
		std::string send_data(_data);
		//在发送
		_socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&Session::handle_read,
			this, placeholders::_1, placeholders::_2));
		boost::asio::async_write(_socket, boost::asio::buffer(send_data, bytes_transfered),
			std::bind(&Session::handle_write, this, placeholders::_1));
	}
	else {
		delete this;
	}
}
```
我们启动day04-SyncClient和day05-AsyncServer分别测试，在Server handle_read里`async_read_some`处打断点，然后启动客户端，客户端发送数据后服务器触发`async_read_some`断点，此时关闭客户端，然后服务器继续执行后面的逻辑会引发崩溃。

![https://cdn.llfc.club/1708481010816.jpg](https://cdn.llfc.club/1708481010816.jpg)

遇到崩溃第一反应是看看崩溃的栈信息，崩溃在最底层代码

![https://cdn.llfc.club/1708482046203.jpg](https://cdn.llfc.club/1708482046203.jpg)

栈信息也看不懂

![https://cdn.llfc.club/1708482122640.jpg](https://cdn.llfc.club/1708482122640.jpg)

看栈调用应该是崩溃在asio底层iocp模型写回调里了。

那我们可以用注释的方式排查问题。我们把handle_write回调里面的逻辑注释掉
``` cpp
void Session::handle_write(const boost::system::error_code& error) {
	// if (!error) {
	// 	memset(_data, 0, max_length);
	// 	_socket.async_read_some(boost::asio::buffer(_data, max_length), std::bind(&Session::handle_read,
	// 		this, placeholders::_1, placeholders::_2));
	// }
	// else {
	// 	delete this;
	// }
}
```
再次启动客户端和服务器，在服务器收到读回调后断点并关闭客户端，服务器放开断点继续执行，未发现崩溃。

观察注释掉的逻辑，最有嫌疑的是`delete this`, 我们仅仅将`delete this`注释掉后就不会崩溃了，那我们找到问题根因了

第一次回调触发handle_read没问题，此时在回调里关闭客户端，因为第一次回调再次调用`async_read_some`将读事件注册给asio底层的事件循环，调用`async_write`将写事件注册给asio底层循环，当客户端关闭后会第二次触发读回调，这次读回调会执行delete操作，delete this之后，Session所有的数据都被回收，而写回调也会触发，因为那么就行了二次delete操作，这就是double free问题。

解决这个问题我们提出了利用智能指针构造一个伪闭包的方式延长Session周期，保证回调之前不会delete Session。具体可以看看这篇文章[https://llfc.club/articlepage?id=2OEQEc6p4k79cXsTr6dOVfZbo79](https://llfc.club/articlepage?id=2OEQEc6p4k79cXsTr6dOVfZbo79)

视频链接

[https://www.bilibili.com/video/BV15P411S7fp/?spm_id_from=333.788&vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9](https://www.bilibili.com/video/BV15P411S7fp/?spm_id_from=333.788&vd_source=8be9e83424c2ed2c9b2a3ed1d01385e9)

本文仅作排查故障方法整理，其他不做赘述，相关处理方案可以看我博客其他文章和视频。

## 资源竞争
资源竞争大部分情况是逻辑错误，比如两个线程A和B同时修改互斥区域，互斥区域未加锁，这期间也可能造成崩溃，比如线程A删除了数据C，而线程B正在访问数据C，引发崩溃后大家不要慌，先看崩溃的堆栈信息，如果是指针显示为0xdddd之类的说明是访问了被删除的数据，那么我们排查删除的逻辑，或者屏蔽删除的逻辑看看会不会出问题，基本思路是
1. 崩溃看堆栈信息，排查是不是野指针或者double free问题。
2. 如果不是崩溃信息，数据混乱就查找修改数据的逻辑，或者屏蔽这个逻辑，看看是不是多线程造成的。
3. 崩溃问题也可以通过屏蔽部分逻辑排查是不是多线程导致的。
4. 在必要的逻辑区间增加日志，排查逻辑异常的上层原因。

这部分问题要结合实际工作去排查，慢慢熟悉这种思路以后就不陌生了。
## 死锁问题
多线程出现死锁问题是很头疼，现象不如内存崩溃或者资源竞争那么明显，表现给开发者的是一种卡死的现象。造成死锁的根本原因在于锁资源互相竞争，遇到这种问题要先梳理逻辑，找到互相引用的关键点。
我们通过代码仓库中concurrent文件夹day24-TroubleShoot 中deadlock.h演示
``` cpp
void deadlockdemo() {
	std::mutex mtx;
	int global_data = 0;
	std::thread t1([&mtx, &global_data]() {
		std::lock_guard<std::mutex> outer_lock(mtx);
		global_data++;
		std::async([&mtx, &global_data]() {
			std::lock_guard<std::mutex> inner_lock(mtx);
			global_data++;
			std::cout << global_data << std::endl;
			});
		
	});

	t1.join();
}
```
主函数调用这个函数，主进程无法退出。因为不是崩溃问题所以无法查看调用栈，对于这个问题，我们在关键位置打印日志，看看具体走到哪里出了问题。
``` cpp
void deadlockdemo() {
	std::mutex mtx;
	int global_data = 0;
	std::thread t1([&mtx, &global_data]() {
		std::cout << "begin lock outer_lock..." << std::endl;
		std::lock_guard<std::mutex> outer_lock(mtx);
		std::cout << "after lock outer_lock..." << std::endl;
		global_data++;
		std::async([&mtx, &global_data]() {
			std::cout << "begin lock inner_lock..." << std::endl;
			std::lock_guard<std::mutex> inner_lock(mtx);
			std::cout << "after lock inner_lock..." << std::endl;
			global_data++;
			std::cout << global_data << std::endl;
			std::cout << "unlock inner_lock..." << std::endl;
			});
		std::cout << "unlock  outer_lock..." << std::endl;
	});

	t1.join();
}
```
日志输出
``` bash
begin lock outer_lock...
after lock outer_lock...
begin lock inner_lock...
```
可以看到内部锁没有加成功。这种情况就是死锁了，再来分析原因，因为async会返回一个future，作为右值这个future会立即调用析构函数，析构函数内部会等待任务完成(并发编程已经从源码剖析了，这里不再赘述)。内部任务要加锁加不上，外部解不开锁因为async返回的future析构无法调用成功。这就是死锁的原因了。
修正，只要让future不立即调用析构即可，我们可以用变量接受future,这样析构就会延缓到解锁之后，变量可以放在最外层，这样变量不会触发析构。
``` cpp
void lockdemo() {
	std::mutex mtx;
	int global_data = 0;
	std::future<void> future_res;
	std::thread t1([&mtx, &global_data,&future_res]() {
		std::cout << "begin lock outer_lock..." << std::endl;
		std::lock_guard<std::mutex> outer_lock(mtx);
		std::cout << "after lock outer_lock..." << std::endl;
		global_data++;
		future_res = std::async([&mtx, &global_data]() {
			std::cout << "begin lock inner_lock..." << std::endl;
			std::lock_guard<std::mutex> inner_lock(mtx);
			std::cout << "after lock inner_lock..." << std::endl;
			global_data++;
			std::cout << global_data << std::endl;
			std::cout << "unlock inner_lock..." << std::endl;
			});
		std::cout << "unlock  outer_lock..." << std::endl;
		});

	t1.join();
}
```
程序输出
``` cpp
begin lock outer_lock...
after lock outer_lock...
unlock  outer_lock...
begin lock inner_lock...
after lock inner_lock...
2
unlock inner_lock...
```
关于活锁，解决方式类似，在关键位置添加注释排查具体原因。
## 引用释放的变量
随着C++ 11 lambda表达式推出后，编程更方便了，但是引用释放的变量这个问题也随之而来。