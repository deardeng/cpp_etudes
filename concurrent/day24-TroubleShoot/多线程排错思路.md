## 简介
到目前为止，前面一系列的文章已经将多线程编程技术介绍完了，很多人问我如何排查多线程程序的问题，本节是最后一节，给大家提供一些在多线程编程过程中排查问题的思路。因为本节代码演示和实际操作内容较多，该文档仅做基本的说明，详细操作可看视频， 视频链接：

[https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290](https://space.bilibili.com/271469206/channel/collectiondetail?sid=1623290)

## 常见问题
在介绍如何排查前我们先将问题做几个归类：
1. 内存问题，包括内存泄露(未回收内存)，空指针，悬垂指针(野指针)，double free问题等。
2. 资源竞争，多个线程竞争同一块临界区的资源，未保证互斥
3. 死锁(互相引用阻塞卡死)和活锁(乐观锁尝试)
4. 引用已释放的变量，生命周期管理失效导致
5. 线程管控失败，修改或者回收一个已经绑定正在运行线程的变量，或者线程本该回收却被卡死，皆因线程管控失败导致
6. 未保证异步回调次序导致数据混乱

接下来根据上面列出的问题，我们根据实际案例排查出现问题的原因以及规避的方法。

接下来的案例均取自我的源码，源码链接如下：

[https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot](https://gitee.com/secondtonone1/boostasio-learn/tree/master/concurrent/day24-TroubleShoot)


## 空指针
空指针的问题比较好排查，我们在封装无锁队列的时候照抄《C++并发编程实战》一书引发了崩溃，详见源码链接中crushque.h以及lockfreequetest.cpp。

测试用例如下：
``` cpp
void TestCrushQue() {
	crush_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT * 10000; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
		});

	std::thread t2([&]() {
		for (int i = 0; i < TESTCOUNT * 10000;) {
			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			i++;
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();
	t2.join();

}
```

最后显示的崩溃点在

![https://cdn.llfc.club/1708328384150.jpg](https://cdn.llfc.club/1708328384150.jpg)

很明显这是引发崩溃的底层代码，并不是上层代码，通过调用堆栈找到和崩溃最相近的逻辑

![https://cdn.llfc.club/1708328755799.jpg](https://cdn.llfc.club/1708328755799.jpg)

我们点击第二行的栈调用跳转到队列的push操作。

![https://cdn.llfc.club/1708328906480.jpg](https://cdn.llfc.club/1708328906480.jpg)

在代码166行处是崩溃的上层调用，我们通过分析old_tail.ptr此时为空指针，该问题的根因在于构造无锁队列时未进行头节点和尾部节点的初始化所致。

无论linux还是windows，排查崩溃问题最首要的解决方式为观察栈调用，gdb或者windows的栈信息直观的反应了崩溃的触发顺序。

## 内存泄漏

一般来说内存泄漏检测有专门的工具库，linux环境下可使用valgrind，windows的visual studio环境下Visual Leak Detector， 这些工具只能被动的检测内存泄漏，很多情况我们需要针对已经开发的类或者逻辑编写测试用例，检测内存泄漏。

比如我们对于无锁队列中提供了一个内存泄漏的版本，详见memoryleakque.h以及测试用例lockfreequetest.cpp，以下为测试代码
``` cpp
void TestLeakQue() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));
		}
		});

	std::thread t2([&]() {
		for (int i = 0; i < TESTCOUNT;) {
			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			i++;
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();
	t2.join();

	assert(que.destruct_count == TESTCOUNT);

}
```

针对这个队列, 我们统计释放节点的个数和开辟节点的个数是否相等，通过`assert(que.destruct_count == TESTCOUNT);`断言检测，实际测试过程中发现存在内存泄漏。

![https://cdn.llfc.club/1708330464493.jpg](https://cdn.llfc.club/1708330464493.jpg)

针对无锁队列的内存泄漏无外乎就是push和pop操作造成的，我们把测试用例改为单线程，先将多线程这个可变因素去掉
``` cpp
void TestLeakQueSingleThread() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));

			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p << std::endl;
		}
		});

	t1.join();

	assert(que.destruct_count == TESTCOUNT);
}
```
上面的代码测试未发现内存泄漏，但这还不能将问题归因于多线程，我们构造一种情况触发空队列的pop
``` cpp
void TestLeakQueMultiPop() {
	memoryleak_que<int>  que;
	std::thread t1([&]() {
		for (int i = 0; i < TESTCOUNT; i++) {
			que.push(i);
			std::cout << "push data is " << i << std::endl;
			std::this_thread::sleep_for(std::chrono::milliseconds(10));

			auto p = que.pop();
			if (p == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p << std::endl;

			auto p2 = que.pop();
			if (p2 == nullptr) {
				std::this_thread::sleep_for(std::chrono::milliseconds(10));
				continue;
			}
			std::cout << "pop data is " << *p2 << std::endl;
		}
		});

	t1.join();

	assert(que.destruct_count == TESTCOUNT);
}
```
上面的代码再一次触发断言，说明存在内存泄漏，那我们可以将问题归因于pop操作，而且是队列为空的pop操作。

接下来配合断点调试，windows断点调试较为方便，或者linux环境gdb调试麻烦，可以在关键点打印信息排查问题。

我们使用visual studio断点排查这个问题，先让队列push一个数据，再pop两次，第二次pop肯定无效因为是空队列，但也是引发泄漏的关键原因。

接下来再push一个数据，再pop节点，我们需观察这次pop是否会触发节点回收的逻辑。

回收节点的逻辑只有两处，在release_ref和free_external_counter内部判断internal_count和external_counters为0时才会调用delete回收内存，所以我们只需要在release_ref和free_external_counter中打断点，观察这两个引用计数是否为0，如果不为0说明引用计数的计算出了问题。

![https://cdn.llfc.club/1708334690329.jpg](https://cdn.llfc.club/1708334690329.jpg)

为了便于观察数据，我们采取单步调试的方式，经过断点调试，发现第二次循环pop时，`free_external_count`内部`old_node_ptr.external_count`为3，而第一次循环pop时`old_node_ptr.external_count`为2. 那么第二次计算`internal_count`就不会为0，导致节点不会回收。

问题的根因也找到了在pop判断队列为空的时候直接返回了，之前进行了`increase_external_count`将外部引用计数增加了，在判断队列为空未进行修改就返回了，我们知道外部引用计数只是一个副本，可能同时有多个线程修改外部引用计数，所以只需要让内部引用计数释放一次即可
``` cpp
if (ptr == tail.load().ptr)
{
    ptr->release_ref();
    return std::unique_ptr<T>();
}
```
再次测试未发现内存泄漏。
## double free
对于悬垂指针也叫做野指针，指的是释放内存后，再次使用这个指针访问数据造成崩溃。double free也属于指针管理失效导致，我们看看网络编程中对官方案例存在隐患的剖析。案例在网络编程network文件夹，day05-AsyncServer中，我们启动day04-SyncClient和day05-AsyncServer分别测试，在Server收到消息准备发送echo发送数据前打断点，然后关闭客户端，可以看到server崩溃。

